// Generated by CoffeeScript 1.10.0

/* @file lampyridae.js
 * @Copyright (c) 2016 Taylor Siviter
 * This source code is licensed under the MIT License.
 * For full information, see the LICENSE file in the project root.
 */

(function() {
  var initL;

  initL = (function() {
    var err;
    if (window.Lampyridae == null) {
      return window.Lampyridae = {};
    } else {
      err = new Error('Lampyridae namespace could not be assigned. Is there a conflict?');
      err.name = 'FatalError';
      throw err;
    }
  })();


  /* Global application settings
   */

  window.Lampyridae.bugDefaultColour = "#FAFF0A";

  window.Lampyridae.bugHueMax = 102.72;

  window.Lampyridae.bugHueMin = 65.28;

  window.Lampyridae.bugSaturation = 1.0;

  window.Lampyridae.bugLightness = 0.5;

  window.Lampyridae.bugRadiusMax = 1.5;

  window.Lampyridae.bugRadiusMin = 0.2;

  window.Lampyridae.bugTurningAngle = 0.25 * Math.PI;

  window.Lampyridae.timestep = 1;

  Lampyridae.Bug = (function() {

    /* Construct and manage a Lampyridae bug 'particle'
     *
     * @param id [String] Name of the #id selector for the canvas element
     * @param parent [String] Name of the element to attatch the canvas to (defaults to body)
     * @todo Add options + add selection of an exisiting canvas
     */
    function Bug(x, y, theta, v, canvas1) {
      this.x = x;
      this.y = y;
      this.theta = theta;
      this.v = v;
      this.canvas = canvas1;
      this.radius = (Lampyridae.bugRadiusMax - Lampyridae.bugRadiusMin) * Math.random() + Lampyridae.bugRadiusMin;
      return;
    }

    Bug.prototype.vx = function() {
      return this.v * Math.cos(this.theta);
    };

    Bug.prototype.vy = function() {
      return this.v * Math.sin(this.theta);
    };

    Bug.prototype.move = function() {
      this.x += Lampyridae.timestep * this.vx();
      this.y += Lampyridae.timestep * this.vy();
    };

    Bug.prototype.turn = function(angle) {
      if (angle == null) {
        angle = 0.0;
      }
      this.theta += angle;
    };

    Bug.prototype.turnAround = function() {
      this.turn(Math.PI);
    };

    Bug.prototype.randomTurn = function() {
      this.turn(Lampyridae.bugTurningAngle * (2.0 * Math.random() - 1.0));
    };

    Bug.prototype.isOutsideCanvas = function() {
      var ref, ref1;
      if (!((0.0 <= (ref = this.x) && ref <= this.canvas.width()))) {
        return true;
      } else if (!((0.0 <= (ref1 = this.y) && ref1 <= this.canvas.height()))) {
        return true;
      }
      return false;
    };

    Bug.prototype.hardBoundedFlight = function() {
      if (!this.isOutsideCanvas()) {
        this.randomTurn();
      } else {
        this.turnAround();
        while (!this.isOutsideCanvas()) {
          this.move;
        }
      }
      this.move();
    };

    Bug.prototype.fly = function() {
      this.hardBoundedFlight();
    };

    Bug.prototype.update = function() {
      this.fly();
      this.draw();
    };

    Bug.prototype.draw = function() {
      this.canvas.context.beginPath();
      this.canvas.context.arc(this.x, this.y, this.radius, 0.0, 2.0 * Math.PI, false);
      this.canvas.context.fillStyle = Lampyridae.bugDefaultColour;
      this.canvas.context.fill();
    };

    return Bug;

  })();

  Lampyridae.Canvas = (function() {

    /* Construct and manage a canvas element
     *
     * @param id [String] Name of the #id selector for the canvas element
     * @param parent [String] Name of the element to attatch the canvas to (defaults to body)
     * @todo Add options + add selection of an exisiting canvas
     */
    function Canvas(id, parent) {
      this.id = id;
      this.parent = parent != null ? parent : 'body';
      if (!(arguments.length >= 1)) {
        throw new Error("Canvas requires an \#id selector");
      }
      this.element = document.createElement('canvas');
      this.context = this.element.getContext('2d');
      this.setID();
      this.append();
      this.resizeToParent();
      $(window).resize((function(_this) {
        return function() {
          _this.resizeToParent();
        };
      })(this));
      return;
    }

    Canvas.prototype.width = function() {
      return $(this.element).width();
    };

    Canvas.prototype.height = function() {
      return $(this.element).height();
    };

    Canvas.prototype.setWidth = function(width) {
      if (width == null) {
        width = $(this.parent).innerWidth();
      }
      $(this.element).width(width).attr('width', width);
      return width;
    };

    Canvas.prototype.setHeight = function(height) {
      if (height == null) {
        height = $(this.parent).innerHeight();
      }
      $(this.element).height(height).attr('height', height);
      return height;
    };

    Canvas.prototype.setID = function(id) {
      this.id = id != null ? id : this.id;
      $(this.element).attr('id', this.id);
      return this.id;
    };

    Canvas.prototype.append = function(parent) {
      this.parent = parent != null ? parent : this.parent;
      $(this.parent).append(this.element);
      console.log("Lampyridae: Appended \#" + this.id + " to " + this.parent);
    };

    Canvas.prototype.resizeToParent = function() {
      this.setWidth();
      this.setHeight();
    };

    Canvas.prototype.clear = function() {
      this.context.clearRect(0, 0, this.width(), this.height());
    };

    return Canvas;

  })();


  /* Converts HSL colour to RGB.
   * Code adapted from:
   * @see https://github.com/bgrins/TinyColor
   * @see http://serennu.com/colour/rgbtohsl.php
   *
   * @param h [Number] The hue [0, 360]
   * @param s [Number] The saturation [0, 100]%
   * @param l [Number] The lightness [0, 100]%
   * @return [Array] The RGB representation [0, 255]
   */

  Lampyridae.hslToRgb = function(h, s, l) {
    var b, g, hue2rgb, p, q, r;
    h = parseFloat(h) / 360.0;
    s = parseFloat(s) / 100.0;
    l = parseFloat(l) / 100.0;
    if (s === 0) {
      r = g = b = l;
    } else {
      hue2rgb = function(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 0.5) {
          return q;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6.0 * t;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (4 - 6.0 * t);
        }
        return p;
      };
      q = l < 0.5 ? l * (1 + s) : l + s - (l * s);
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [255 * r, 255 * g, 255 * b];
  };


  /*
   * Example usage
   */

  $(document).ready(function() {
    var animate, bugs, canvas, createBugs, numOfBugs, update;
    canvas = new Lampyridae.Canvas('world');
    numOfBugs = 50;
    bugs = [];
    createBugs = function() {
      var bug, i, j, ref;
      for (i = j = 0, ref = numOfBugs; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        bug = new Lampyridae.Bug(25, 25, 0, 8, canvas);
        bugs.push(bug);
      }
    };
    animate = function() {
      canvas.clear();
      update();
      requestAnimationFrame(animate);
    };
    update = function() {
      var i, j, ref;
      for (i = j = 0, ref = numOfBugs; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        bugs[i].update();
      }
    };
    createBugs();
    animate();
  });

}).call(this);
